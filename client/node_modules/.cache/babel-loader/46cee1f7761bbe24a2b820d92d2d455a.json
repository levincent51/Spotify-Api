{"ast":null,"code":"import _regeneratorRuntime from\"/Users/macuser/project/spotify-api-project/client/node_modules/@babel/runtime/regenerator\";import _toConsumableArray from\"/Users/macuser/project/spotify-api-project/client/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _asyncToGenerator from\"/Users/macuser/project/spotify-api-project/client/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import{spotifyApi,token,getAccessToken}from\"../components/spotifyAPI\";export var getplaylists=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(playlists,limit,offset){var newOffset,newPlaylist;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:newOffset=offset+limit;_context.next=3;return spotifyApi.getUserPlaylists({limit:limit,offset:offset}).then(function(response){if(response){console.log(response);newPlaylist=[].concat(_toConsumableArray(playlists),_toConsumableArray(response.items));if(response.next){newPlaylist=getplaylists(newPlaylist,limit,newOffset);}}}).catch(function(){getAccessToken();});case 3:return _context.abrupt(\"return\",newPlaylist);case 4:case\"end\":return _context.stop();}}},_callee);}));return function getplaylists(_x,_x2,_x3){return _ref.apply(this,arguments);};}();var getTrackfromPlaylist=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(playlistId,tracks,limit,offset){var newOffset,newTrack;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:newOffset=offset+limit;_context2.next=3;return spotifyApi.getPlaylistTracks(token,playlistId,{limit:limit,offset:offset}).then(function(response){if(response){newTrack=[].concat(_toConsumableArray(tracks),_toConsumableArray(response.items));if(response.next){newTrack=getTrackfromPlaylist(playlistId,newTrack,limit,newOffset);}}});case 3:console.log(newTrack);return _context2.abrupt(\"return\",newTrack);case 5:case\"end\":return _context2.stop();}}},_callee2);}));return function getTrackfromPlaylist(_x4,_x5,_x6,_x7){return _ref2.apply(this,arguments);};}();export var getAllSongs=/*#__PURE__*/function(){var _ref3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(res){var c;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:console.log(res);_context3.next=3;return getTrackfromPlaylist(res,[],100,0).then(function(response){if(response){console.log(response);var filter=response.filter(function(x){return x.track;});return filter.map(function(x){return x.id;});//response.map(x => x.track.id)\n}});case 3:c=_context3.sent;return _context3.abrupt(\"return\",c);case 5:case\"end\":return _context3.stop();}}},_callee3);}));return function getAllSongs(_x8){return _ref3.apply(this,arguments);};}();export function arraySplice(array,size){var a=array;var spliced=[];if(array){while(a.length){spliced=[].concat(_toConsumableArray(spliced),[a.splice(0,size)]);}}return spliced;}","map":{"version":3,"sources":["/Users/macuser/project/spotify-api-project/client/src/components/UserSongs.js"],"names":["spotifyApi","token","getAccessToken","getplaylists","playlists","limit","offset","newOffset","getUserPlaylists","then","response","console","log","newPlaylist","items","next","catch","getTrackfromPlaylist","playlistId","tracks","getPlaylistTracks","newTrack","getAllSongs","res","filter","x","track","map","id","c","arraySplice","array","size","a","spliced","length","splice"],"mappings":"iZACA,OAASA,UAAT,CAAqBC,KAArB,CAA4BC,cAA5B,KAAkD,0BAAlD,CAGA,MAAO,IAAMC,CAAAA,YAAY,0FAAG,iBAAOC,SAAP,CAAkBC,KAAlB,CAAyBC,MAAzB,4IACrBC,SADqB,CACTD,MAAM,CAAGD,KADA,uBAGrBL,CAAAA,UAAU,CACfQ,gBADK,CACY,CACjBH,KAAK,CAAEA,KADU,CAEjBC,MAAM,CAAEA,MAFS,CADZ,EAKJG,IALI,CAKC,SAACC,QAAD,CAAc,CACpB,GAAIA,QAAJ,CAAc,CACbC,OAAO,CAACC,GAAR,CAAYF,QAAZ,EACAG,WAAW,8BAAOT,SAAP,qBAAqBM,QAAQ,CAACI,KAA9B,EAAX,CACA,GAAIJ,QAAQ,CAACK,IAAb,CAAmB,CACnBF,WAAW,CAAGV,YAAY,CAACU,WAAD,CAAcR,KAAd,CAAqBE,SAArB,CAA1B,CACC,CACD,CACA,CAbI,EAcJS,KAdI,CAcE,UAAM,CACbd,cAAc,GACd,CAhBK,CAHqB,wCAoBpBW,WApBoB,wDAAH,kBAAZV,CAAAA,YAAY,oDAAlB,CAuBP,GAAMc,CAAAA,oBAAoB,2FAAG,kBAAOC,UAAP,CAAmBC,MAAnB,CAA2Bd,KAA3B,CAAkCC,MAAlC,6IACtBC,SADsB,CACVD,MAAM,CAAGD,KADC,wBAGtBL,CAAAA,UAAU,CACdoB,iBADI,CACcnB,KADd,CACqBiB,UADrB,CACiC,CAAEb,KAAK,CAAEA,KAAT,CAAgBC,MAAM,CAAEA,MAAxB,CADjC,EAEJG,IAFI,CAEC,SAACC,QAAD,CAAc,CACpB,GAAIA,QAAJ,CAAc,CACbW,QAAQ,8BAAOF,MAAP,qBAAkBT,QAAQ,CAACI,KAA3B,EAAR,CACA,GAAIJ,QAAQ,CAACK,IAAb,CAAmB,CACnBM,QAAQ,CAAGJ,oBAAoB,CAC9BC,UAD8B,CAE9BG,QAF8B,CAG9BhB,KAH8B,CAI9BE,SAJ8B,CAA/B,CAMC,CACD,CACA,CAdI,CAHsB,QAmB5BI,OAAO,CAACC,GAAR,CAAYS,QAAZ,EAnB4B,iCAqBrBA,QArBqB,0DAAH,kBAApBJ,CAAAA,oBAAoB,0DAA1B,CA0BA,MAAO,IAAMK,CAAAA,WAAW,2FAAG,kBAAOC,GAAP,4HAE1BZ,OAAO,CAACC,GAAR,CAAYW,GAAZ,EAF0B,uBAGVN,CAAAA,oBAAoB,CAACM,GAAD,CAAM,EAAN,CAAU,GAAV,CAAe,CAAf,CAApB,CAAsCd,IAAtC,CAA2C,SAACC,QAAD,CAAc,CACxE,GAAIA,QAAJ,CAAc,CACbC,OAAO,CAACC,GAAR,CAAYF,QAAZ,EACA,GAAMc,CAAAA,MAAM,CAAGd,QAAQ,CAACc,MAAT,CAAgB,SAACC,CAAD,QAAOA,CAAAA,CAAC,CAACC,KAAT,EAAhB,CAAf,CAEA,MAAOF,CAAAA,MAAM,CAACG,GAAP,CAAW,SAACF,CAAD,QAAOA,CAAAA,CAAC,CAACG,EAAT,EAAX,CAAP,CACD;AACC,CACD,CARe,CAHU,QAGpBC,CAHoB,iDAanBA,CAbmB,0DAAH,kBAAXP,CAAAA,WAAW,8CAAjB,CAgBP,MAAO,SAASQ,CAAAA,WAAT,CAAqBC,KAArB,CAA4BC,IAA5B,CAAkC,CACxC,GAAIC,CAAAA,CAAC,CAAGF,KAAR,CACA,GAAIG,CAAAA,OAAO,CAAG,EAAd,CACA,GAAIH,KAAJ,CAAW,CACV,MAAOE,CAAC,CAACE,MAAT,CAAiB,CACjBD,OAAO,8BAAOA,OAAP,GAAgBD,CAAC,CAACG,MAAF,CAAS,CAAT,CAAYJ,IAAZ,CAAhB,EAAP,CACC,CACD,CACD,MAAOE,CAAAA,OAAP,CACA","sourcesContent":["\nimport { spotifyApi, token, getAccessToken } from \"../components/spotifyAPI\";\n\n\nexport const getplaylists = async (playlists, limit, offset) => {\n\tconst newOffset = offset + limit;\n\tvar newPlaylist;\n\tawait spotifyApi\n\t.getUserPlaylists({\n\t\tlimit: limit,\n\t\toffset: offset,\n\t\t})\n\t\t.then((response) => {\n\t\tif (response) {\n\t\t\tconsole.log(response)\n\t\t\tnewPlaylist = [...playlists, ...response.items];\n\t\t\tif (response.next) {\n\t\t\tnewPlaylist = getplaylists(newPlaylist, limit, newOffset);\n\t\t\t}\n\t\t}\n\t\t})\n\t\t.catch(() => {\n\t\tgetAccessToken();\n\t});\n\treturn newPlaylist;\n};\n\nconst getTrackfromPlaylist = async (playlistId, tracks, limit, offset) => {\n\tconst newOffset = offset + limit;\n\tvar newTrack;\n\tawait spotifyApi\n\t\t.getPlaylistTracks(token, playlistId, { limit: limit, offset: offset })\n\t\t.then((response) => {\n\t\tif (response) {\n\t\t\tnewTrack = [...tracks, ...response.items];\n\t\t\tif (response.next) {\n\t\t\tnewTrack = getTrackfromPlaylist(\n\t\t\t\tplaylistId,\n\t\t\t\tnewTrack,\n\t\t\t\tlimit,\n\t\t\t\tnewOffset\n\t\t\t);\n\t\t\t}\n\t\t}\n\t\t});\n\n\tconsole.log(newTrack)\n\t\n\treturn newTrack; // AFTER THIS ARRAY.JOIN THEM ALL TO GET ALL THE track IDS WE NEED\n};\n\n\n\nexport const getAllSongs = async (res) => {\n\n\tconsole.log(res)\n\tconst c = await getTrackfromPlaylist(res, [], 100, 0).then((response) => {\n\t\tif (response) {\n\t\t\tconsole.log(response)\n\t\t\tconst filter = response.filter((x) => x.track)\n\n\t\t\treturn filter.map((x) => x.id);\n\t\t//response.map(x => x.track.id)\n\t\t}\n\t});\n\n\treturn c;\n};\n\nexport function arraySplice(array, size) {\n\tvar a = array;\n\tvar spliced = [];\n\tif (array) {\n\t\twhile (a.length) {\n\t\tspliced = [...spliced, a.splice(0, size)];\n\t\t}\n\t}\n\treturn spliced;\n}\n\n\n\n\n\n "]},"metadata":{},"sourceType":"module"}