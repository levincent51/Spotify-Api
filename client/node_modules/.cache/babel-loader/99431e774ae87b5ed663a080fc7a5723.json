{"ast":null,"code":"import { spotifyApi, token, getAccessToken } from \"../components/spotifyAPI\";\nexport const getplaylists = async (playlists, limit, offset) => {\n  const newOffset = offset + limit;\n  var newPlaylist;\n  await spotifyApi.getUserPlaylists({\n    limit: limit,\n    offset: offset\n  }).then(response => {\n    if (response) {\n      console.log(response);\n      newPlaylist = [...playlists, ...response.items];\n\n      if (response.next) {\n        newPlaylist = getplaylists(newPlaylist, limit, newOffset);\n      }\n    }\n  }).catch(() => {\n    getAccessToken();\n  });\n  return newPlaylist;\n};\n\nconst getTrackfromPlaylist = async (playlistId, tracks, limit, offset) => {\n  const newOffset = offset + limit;\n  var newTrack;\n  await spotifyApi.getPlaylistTracks(token, playlistId, {\n    limit: limit,\n    offset: offset\n  }).then(response => {\n    if (response) {\n      newTrack = [...tracks, ...response.items];\n\n      if (response.next) {\n        newTrack = getTrackfromPlaylist(playlistId, newTrack, limit, newOffset);\n      }\n    }\n  });\n  return newTrack; // AFTER THIS ARRAY.JOIN THEM ALL TO GET ALL THE track IDS WE NEED\n};\n\nexport const getAllSongs = res => {\n  const c = getTrackfromPlaylist(res, [], 100, 0).then(response => {\n    if (response) {\n      console.log(response);\n      return response.map(x => x.track.id); //response.map(x => x.track.id)\n    }\n  });\n  return c;\n};\nexport function arraySplice(array, size) {\n  var a = array;\n  var spliced = [];\n\n  if (array) {\n    while (a.length) {\n      spliced = [...spliced, a.splice(0, size)];\n    }\n  }\n\n  return spliced;\n}","map":{"version":3,"sources":["/Users/macuser/project/spotify-api-project/client/src/components/UserSongs.js"],"names":["spotifyApi","token","getAccessToken","getplaylists","playlists","limit","offset","newOffset","newPlaylist","getUserPlaylists","then","response","console","log","items","next","catch","getTrackfromPlaylist","playlistId","tracks","newTrack","getPlaylistTracks","getAllSongs","res","c","map","x","track","id","arraySplice","array","size","a","spliced","length","splice"],"mappings":"AACA,SAASA,UAAT,EAAqBC,KAArB,EAA4BC,cAA5B,QAAkD,0BAAlD;AAGA,OAAO,MAAMC,YAAY,GAAG,OAAOC,SAAP,EAAkBC,KAAlB,EAAyBC,MAAzB,KAAoC;AAC/D,QAAMC,SAAS,GAAGD,MAAM,GAAGD,KAA3B;AACA,MAAIG,WAAJ;AACA,QAAMR,UAAU,CACfS,gBADK,CACY;AACjBJ,IAAAA,KAAK,EAAEA,KADU;AAEjBC,IAAAA,MAAM,EAAEA;AAFS,GADZ,EAKJI,IALI,CAKEC,QAAD,IAAc;AACpB,QAAIA,QAAJ,EAAc;AACbC,MAAAA,OAAO,CAACC,GAAR,CAAYF,QAAZ;AACAH,MAAAA,WAAW,GAAG,CAAC,GAAGJ,SAAJ,EAAe,GAAGO,QAAQ,CAACG,KAA3B,CAAd;;AACA,UAAIH,QAAQ,CAACI,IAAb,EAAmB;AACnBP,QAAAA,WAAW,GAAGL,YAAY,CAACK,WAAD,EAAcH,KAAd,EAAqBE,SAArB,CAA1B;AACC;AACD;AACA,GAbI,EAcJS,KAdI,CAcE,MAAM;AACbd,IAAAA,cAAc;AACd,GAhBK,CAAN;AAiBA,SAAOM,WAAP;AACA,CArBM;;AAuBP,MAAMS,oBAAoB,GAAG,OAAOC,UAAP,EAAmBC,MAAnB,EAA2Bd,KAA3B,EAAkCC,MAAlC,KAA6C;AACzE,QAAMC,SAAS,GAAGD,MAAM,GAAGD,KAA3B;AACA,MAAIe,QAAJ;AACA,QAAMpB,UAAU,CACdqB,iBADI,CACcpB,KADd,EACqBiB,UADrB,EACiC;AAAEb,IAAAA,KAAK,EAAEA,KAAT;AAAgBC,IAAAA,MAAM,EAAEA;AAAxB,GADjC,EAEJI,IAFI,CAEEC,QAAD,IAAc;AACpB,QAAIA,QAAJ,EAAc;AACbS,MAAAA,QAAQ,GAAG,CAAC,GAAGD,MAAJ,EAAY,GAAGR,QAAQ,CAACG,KAAxB,CAAX;;AACA,UAAIH,QAAQ,CAACI,IAAb,EAAmB;AACnBK,QAAAA,QAAQ,GAAGH,oBAAoB,CAC9BC,UAD8B,EAE9BE,QAF8B,EAG9Bf,KAH8B,EAI9BE,SAJ8B,CAA/B;AAMC;AACD;AACA,GAdI,CAAN;AAgBA,SAAOa,QAAP,CAnByE,CAmBxD;AACjB,CApBD;;AAwBA,OAAO,MAAME,WAAW,GAAIC,GAAD,IAAS;AACnC,QAAMC,CAAC,GAAGP,oBAAoB,CAACM,GAAD,EAAM,EAAN,EAAU,GAAV,EAAe,CAAf,CAApB,CAAsCb,IAAtC,CAA4CC,QAAD,IAAc;AAClE,QAAIA,QAAJ,EAAc;AACbC,MAAAA,OAAO,CAACC,GAAR,CAAYF,QAAZ;AACD,aAAOA,QAAQ,CAACc,GAAT,CAAcC,CAAD,IAAOA,CAAC,CAACC,KAAF,CAAQC,EAA5B,CAAP,CAFc,CAGd;AACC;AACD,GANS,CAAV;AAQA,SAAOJ,CAAP;AACA,CAVM;AAYP,OAAO,SAASK,WAAT,CAAqBC,KAArB,EAA4BC,IAA5B,EAAkC;AACxC,MAAIC,CAAC,GAAGF,KAAR;AACA,MAAIG,OAAO,GAAG,EAAd;;AACA,MAAIH,KAAJ,EAAW;AACV,WAAOE,CAAC,CAACE,MAAT,EAAiB;AACjBD,MAAAA,OAAO,GAAG,CAAC,GAAGA,OAAJ,EAAaD,CAAC,CAACG,MAAF,CAAS,CAAT,EAAYJ,IAAZ,CAAb,CAAV;AACC;AACD;;AACD,SAAOE,OAAP;AACA","sourcesContent":["\nimport { spotifyApi, token, getAccessToken } from \"../components/spotifyAPI\";\n\n\nexport const getplaylists = async (playlists, limit, offset) => {\n\tconst newOffset = offset + limit;\n\tvar newPlaylist;\n\tawait spotifyApi\n\t.getUserPlaylists({\n\t\tlimit: limit,\n\t\toffset: offset,\n\t\t})\n\t\t.then((response) => {\n\t\tif (response) {\n\t\t\tconsole.log(response)\n\t\t\tnewPlaylist = [...playlists, ...response.items];\n\t\t\tif (response.next) {\n\t\t\tnewPlaylist = getplaylists(newPlaylist, limit, newOffset);\n\t\t\t}\n\t\t}\n\t\t})\n\t\t.catch(() => {\n\t\tgetAccessToken();\n\t});\n\treturn newPlaylist;\n};\n\nconst getTrackfromPlaylist = async (playlistId, tracks, limit, offset) => {\n\tconst newOffset = offset + limit;\n\tvar newTrack;\n\tawait spotifyApi\n\t\t.getPlaylistTracks(token, playlistId, { limit: limit, offset: offset })\n\t\t.then((response) => {\n\t\tif (response) {\n\t\t\tnewTrack = [...tracks, ...response.items];\n\t\t\tif (response.next) {\n\t\t\tnewTrack = getTrackfromPlaylist(\n\t\t\t\tplaylistId,\n\t\t\t\tnewTrack,\n\t\t\t\tlimit,\n\t\t\t\tnewOffset\n\t\t\t);\n\t\t\t}\n\t\t}\n\t\t});\n\n\treturn newTrack; // AFTER THIS ARRAY.JOIN THEM ALL TO GET ALL THE track IDS WE NEED\n};\n\n\n\nexport const getAllSongs = (res) => {\n\tconst c = getTrackfromPlaylist(res, [], 100, 0).then((response) => {\n\t\tif (response) {\n\t\t\tconsole.log(response)\n\t\treturn response.map((x) => x.track.id);\n\t\t//response.map(x => x.track.id)\n\t\t}\n\t});\n\n\treturn c;\n};\n\nexport function arraySplice(array, size) {\n\tvar a = array;\n\tvar spliced = [];\n\tif (array) {\n\t\twhile (a.length) {\n\t\tspliced = [...spliced, a.splice(0, size)];\n\t\t}\n\t}\n\treturn spliced;\n}\n\n\n\n\n\n "]},"metadata":{},"sourceType":"module"}